# BFS 너비 우선 탐색 알고리즘(리스트 구현) - [1..5]
def bfs(graph, start):
    visited = [] # 방문한 노드를 기록하기 위한 리스트
    queue = [start] # 큐를 리스트로 초기화
    
    while queue: # 큐가 빌 때까지 반복
        node = queue.pop(0) # 큐에서 첫번째 원소를 뽑아 출력
        if node not in visited: # 방문하지 않은 노드라면
            visited.append(node) # 방문한 노드처리
            queue.extend(graph[node]) # 인접노드 추가
    return visited

# 그래프를 인접 리스트로 표현
# 노드 번호는 0부터 시작한다고 가정하여 출발
graph = [
    [1, 2],    # 0번 노드와 연결된 노드들 { 0번 노드의 인접 노드인 1, 2를 큐에 추가 => 0출력} [1단계]
    [0, 3, 4], # 1번 노드와 연결된 노드들 { 1번 노드의 인접 노드인 0, 3, 4를 큐에 추가 => 1출력} [2단계]
    [0, 4],    # 2번 노드와 연결된 노드들 { 2번 노드의 인접 노드인 0, 4를 큐에 추가 => 2출력} [2단계]
    [1, 5],    # 3번 노드와 연결된 노드들 { 3번 노드의 인접 노드인 1, 5를 큐에 추가 => 3출력} [3단계]
    [1, 2, 5], # 4번 노드와 연결된 노드들 { 4번 노드의 인접 노드인 1, 2, 5를 큐에 추가 => 4출력} [3단계]
    [3, 4]     # 5번 노드와 연결된 노드들 { 5번 노드의 인접 노드인 3, 4를 큐에 추가 => 5출력} [3단계]
]

result = bfs(graph, 0)
print("리스트")
print(result) # [1, 2, 3, 4, 5] 출력

#        0
#    1       2
#  3   4   5

# 0번 노드에서 시작하여 너비 우선 탐색을 수행하면
# 1 -> 2 -> 3 -> 4 -> 5 순서로 노드를 방문하게 됩니다.
# 따라서 [1, 2, 3, 4, 5]를 출력합니다.
# 너비 우선 탐색은 큐 자료구조를 이용하여 구현합니다.


# BFS 너비 우선 탐색 알고리즘(리스트 구현) - [1..10]    
def bfs(graph, start):
    visited = [] # 방문한 노드를 기록하기 위한 리스트
    queue = [start] # 큐를 리스트로 초기화
    
    while queue: # 큐가 빌 때까지 반복
        node = queue.pop(0) # 큐에서 첫번째 원소를 뽑아 출력
        if node not in visited: # 방문하지 않은 노드라면
            visited.append(node) # 방문한 노드처리
            queue.extend(graph[node]) # 인접노드 추가
    return visited

# 그래프를 인접 리스트로 표현
# 노드 번호는 0부터 시작한다고 가정하여 출발
graph = {
  0:  [1, 2],    # 0번 노드와 연결된 노드들 { 0번 노드의 인접 노드인 1, 2를 큐에 추가 => 0출력} [1단계]
  1:  [0, 3, 4], # 1번 노드와 연결된 노드들 { 1번 노드의 인접 노드인 0, 3, 4를 큐에 추가 => 1출력} [2단계]
  2:  [0, 5, 6],    # 2번 노드와 연결된 노드들 { 2번 노드의 인접 노드인 0, 5, 6를 큐에 추가 => 2출력} [2단계]
  3:  [1, 7, 8],    # 3번 노드와 연결된 노드들 { 3번 노드의 인접 노드인 1, 7, 8를 큐에 추가 => 3출력} [3단계]
  4:  [1, 9, 10], # 4번 노드와 연결된 노드들 { 4번 노드의 인접 노드인 1, 9, 10를 큐에 추가 => 4출력} [3단계]
  5:  [2], # 5번 노드와 연결된 노드들 { 5번 노드의 인접 노드인 2를 큐에 추가 => 5출력} [3단계]
  6:  [2],  # 5번 노드와 연결된 노드들 { 6번 노드의 인접 노드인 2를 큐에 추가 => 6출력} [3단계]
  7:  [3],  # 5번 노드와 연결된 노드들 { 7번 노드의 인접 노드인 3를 큐에 추가 => 7출력} [4단계]
  8:  [3],  # 5번 노드와 연결된 노드들 { 8번 노드의 인접 노드인 3를 큐에 추가 => 8출력} [4단계]
  9:  [4],  # 5번 노드와 연결된 노드들 { 9번 노드의 인접 노드인 4를 큐에 추가 => 9출력} [4단계]
 10:  [4]  # 5번 노드와 연결된 노드들 { 10번 노드의 인접 노드인 4를 큐에 추가 => 10출력} [4단계]
}

result = bfs(graph, 0)
print("\n\n딕셔너리")
print(result) # [1, 2, 3, 4, 5] 출력    

#                 0
#          1             2
#      3       4     5       6
#    7   8   9   10
    
# 0번 노드에서 시작하여 너비 우선 탐색을 수행하면
# 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> 10 순서로 노드를 방문하게 됩니다.
# 따라서 [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]를 출력합니다.
# 너비 우선 탐색은 큐 자료구조를 이용하여 구현한다.

