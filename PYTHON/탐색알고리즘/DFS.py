# DFS 깊이 우선 탐색 알고리즘(리스트 구현) - [1..5]
graph = [ # 그래프를 인접 리스트로 표현
    [], # 0번 노드는 사용하지 않음 (1번 노드부터 시작) [1]
    [2,3], # 1번 노드와 연결된 노드들 [2,3이 들어가고 작은 2가 연결 => 1,2]
    [4,5], # 2번 노드와 연결된 노드들 [4,5가 들어가고 작은 4가 연결 => 1,2,4,]
    [],    # 3번 노드와 연결된 노드들 [그다음 작은 노드 5가 연결 => 1,2,4,5]
    [],    # 4번 노드와 연결된 노드들 [그 다음 작은 노드 마지막 3이 연결된다 => 1,2,4,5,3]
    []     # 5번 노드와 연결된 노드들 [총 출력이 => 1,2,4,5,3]
]

# DFS 함수 정의
# visited: 중복방문을 방지하여 무한 루프에 빠지지 않도록 방문한 노드를 저장하는 집합
def dfs(node, visited):
    if node not in visited: # visited 안에 node가 없다면 참(true)이다
        
        print(node, end=" ") # 방문한 노드 출력
        # (end="" - print()가 출력된후 줄바꿈 대신 공백을 추가해서 출력)
        # 결과적으로 모든 방문한 노드가 한 줄로 출력된다.
        
        visited.add(node) # 현재 노드를 방문 처리
        # 현재 노드가 visited에 없다면, 방문을 하지않은걸로 간주하고 탐색을 진행
        # 그리고 방문한 노드는 visited에 추가한다.
        
        for neighbor in graph[node]: # 인접 노드를 방문
            # neighbor는 DFS 함수에서 현재 노드의 인접 노드를 나타낸다.
            dfs(neighbor, visited) 
            
# DFS 함수 호출
visited = set() # 방문한 노드를 저장
print("리스트")
dfs(1, visited) # 시작 노드는 1번 노드

#              1
#        2          3
#     4     5       

# 초기 호출: dfs(1, visited)

# node = 1
# visited = {} (빈 집합)
# graph[1] = [2, 3] (1번 노드의 인접 노드)
# 출력: 1
# visited = {1}
# 1번 노드의 인접 노드 순회:

# for neighbor in graph[1]:에서 neighbor = 2 (첫 번째 인접 노드)
# dfs(2, visited) 호출
# 2번 노드 탐색: dfs(2, visited)

# node = 2
# visited = {1}
# graph[2] = [4, 5] (2번 노드의 인접 노드)
# 출력: 2
# visited = {1, 2}
# 2번 노드의 인접 노드 순회:

# for neighbor in graph[2]:에서 neighbor = 4 (첫 번째 인접 노드)
# dfs(4, visited) 호출
# 4번 노드 탐색: dfs(4, visited)

# node = 4
# visited = {1, 2}
# graph[4] = [] (4번 노드는 인접 노드가 없음)
# 출력: 4
# visited = {1, 2, 4}
# 함수 종료 (재귀 반환)
# 2번 노드의 다음 인접 노드:

# for neighbor in graph[2]:에서 neighbor = 5 (두 번째 인접 노드)
# dfs(5, visited) 호출
# 5번 노드 탐색: dfs(5, visited)

# node = 5
# visited = {1, 2, 4}
# graph[5] = [] (5번 노드는 인접 노드가 없음)
# 출력: 5
# visited = {1, 2, 4, 5}
# 함수 종료 (재귀 반환)
# 1번 노드의 다음 인접 노드:

# for neighbor in graph[1]:에서 neighbor = 3 (두 번째 인접 노드)
# dfs(3, visited) 호출
# 3번 노드 탐색: dfs(3, visited)

# node = 3
# visited = {1, 2, 4, 5}
# graph[3] = [] (3번 노드는 인접 노드가 없음)
# 출력: 3
# visited = {1, 2, 3, 4, 5}
# 함수 종료 (재귀 반환)
# 탐색 종료:

# 모든 노드가 방문되었으므로 DFS 종료

# DFS 깊이 우선 탐색 알고리즘(딕셔너리 구현) - [1..10]
graph = {
    1: [2, 3], # 1번 노드와 연결된 노드들 [처음 노드 출력 => 1] {1단계}
    2: [4, 5], # 2번 노드와 연결된 노드들 [2와 3 노드 중 작은 노드 2 방문 => 1,2] {2단계} 
    3: [6,7],     # 3번 노드와 연결된 노드들 [4와 5 노드 중 작은 노드 4 방문 => 1,2,4] {3단계}
    4: [8,9],     # 4번 노드와 연결된 노드들 [8과 9 노드 중 작은 노드 8 방문 => 1,2,4,8] {4단계}
    5: [10],      # 5번 노드와 연결된 노드들 [ 그다음 나머지 다음 노드 9 방문 => 1,2,4,8,9] {4단계}
    6: [],      # 6번 노드는 연결된 노드가 없다. [그 다음 다음노드 노드 5 방문 => 1,2,4,8,9,5] {3단계}
    7: [],      # 7번 노드는 연결된 노드가 없다. [그 다음 다음노드 노드 10 방문 => 1,2,4,8,9,5,10] {4단계}
    8: [],      # 8번 노드는 연결된 노드가 없다. [그 다음 다음노드 노드 3 방문 => 1,2,4,8,9,5,10,3] {2단계}
    9: [],      # 9번 노드는 연결된 노드가 없다. [그 다음 다음노드 노드 6 방문 => 1,2,4,8,9,5,10,3,6] {3단계}
    10: [],      # 10번 노드는 연결된 노드가 없다. [그 다음 다음노드 노드 7 방문 => 1,2,4,8,9,5,10,3,6,7] {3단계}
}

def dfs(node, visited):
    if node not in visited:
        print(node, end=" ")
        visited.add(node)
        for neighbor in graph[node]:
            dfs(neighbor, visited)
            
visited = set()
print("\n\n딕셔너리")
dfs(1, visited)

# 호출 흐름과 데이터 흐름은 리스트 구현과 동일하다.
# 단, 인접 리스트를 딕셔너리로 표현하므로 코드가 간결해진다.
# 딕셔너리는 키-값 쌍으로 데이터를 저장하므로 인접 리스트를 표현하기에 적합한거 같다.
#              1
#        2              3
#   4        5       6     7
# 8   9  10